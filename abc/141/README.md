# ABC141

## A
カテゴリ: 実装

やるだけ

## B
カテゴリ: 実装

やるだけ

## C
カテゴリ: 補集合

Q問中P問正解した参加者の残りポイントは K - (Q - P) である。
これが0以上かどうかを判定すればよい。

## D
カテゴリ: 貪欲法

割引券はバラで使用しても結果は変わらない（2進数表記して考えれば明らか）。
したがって、高い品物から順に割引券を使用すればよい。

## E
カテゴリ: 動的計画法

dp[i][j]をi文字目から始まる文字列とj文字目から始まる文字列のうち、最長である接頭辞の長さとする。
S[i] = S[j] ならば dp[i][j] = dp[i + 1][j + 1] + 1 であることを利用してdpを求めればよい。

## F
カテゴリ: 掃き出し法

### 方針

赤のXORを60bitの二進数表記したときの値を R_1 R_2 ... R_60,  青のXORを二進数表記したときの値を B_1 B_2 ... B_60
として考える(R_i, B_i はそれぞれ左からi bit目を表す）。
lexicographicな順序関係なので、(R_1, B_1), (R_2, B_2), ... の順になるべく1を増やすと目的関数は最大化できる。
そこで、まずは各Aの左から1 bit目を考える。
1の個数が0の場合、どのように彩色しても、両者の1bit目は0となる。
1の個数が奇数個の場合、どのように彩色しても、赤のXORと青のXORのうちどちらかは1bit目が1となり、どちらかは0となる。
1の個数が2以上の偶数の場合、1bit目が1である整数を奇数個だけ赤（青）に塗ることで両者のXORの1bit目は1となる。
この場合、何が何でも奇数個ずつ塗るべきである。

各Aの左から2 bit目についても同様の議論が成り立つ。
以降のbitも同様だが、1の個数が2以上の偶数の場合、奇数個ずつ塗れない可能性がある（上位ビットが優先されるため）。
上位ビットを犠牲にすることなく、そのビットも奇数個ずつ塗れるならば塗れば良い。

### 実装

2bit目以降も奇数個ずつ塗れるならば塗る、という処理が難しく思えるが、これは掃き出し法により実現できる。
なぜならば、奇数個塗る、という条件は体F_2における連立方程式に帰着できるからである。
簡単のため、各ビットの1の個数は2以上の偶数であると仮定する（そうでないビットは連立方程式に現れないので、非本質である）。
A_iの左からjビット目をA_i[j]で表すことにする。
このとき、

A_1[1] x_1 xor A_2[1] x_2 xor ... xor A_N[1] x_N = 1
A_1[2] x_2 xor A_2[1] x_2 xor ... xor A_N[2] x_N = 1
...
A_1[60] x_2 xor A_2[60] x_2 xor ... xor A_N[60] x_N = 1

を満たす (x_1, ..., x_N) が存在すればよいことになる（x_i = 1 はA_iを赤で塗ることに対応する）。
あとは、上の式から順に掃き出し法を適用すればよい。
