# ABC127

## A
カテゴリ: 実装

やるだけ

## B
カテゴリ: 実装

やるだけ

## C
カテゴリ: 数学

解は max(min(R) - max(L) + 1, 0) である。

## D
カテゴリ: 貪欲法

集合 {(A_1, 1), ..., (A_N, 1), (C_1, B_1), ..., (C_M, B_M)} について、
第一要素が大きい順にペアを並べた列を (x_1, y_1), ..., (x_{N + M}, y_{N + M}) とする。
y_1 + ... + y_k >= N を満たす最小の k について、
解は、x_1 * y_1 + ... + x_{k - 1} * y_{k - 1} + x_k * (N - (y_1 + ... + y_{k - 1})) である。

## E
カテゴリ: 数学

二つの駒が (x, y), (x', y') に置かれるような駒の配置方法は (NM - 2)C(K - 2) 通りある
（x, y, x', y' に依存しないことに注意）。
したがって、各(x, y), (x', y') のマンハッタン距離の和を求められればよい。
数列の和の公式を用いてこれを求めると、 NM(M(N^2 - 1) + N(M^2 - 1)) / 6 である。
以上より、求める解は (NM - 2) C (K - 2) NM(M(N^2 - 1) + N(M^2 - 1)) / 6 である。

## F
カテゴリ: 優先度付きキュー

各求値クエリについて、それ以前の更新クエリの a を a_1, ..., a_k とする。
このとき、 argmin f は a_1, ..., a_k の中央値である。
ただし、kが偶数の場合、aを昇順ソートした列をAとして、A_{k / 2} である。

中央値を高速に求める方法を考える。優先度付きキューを2つ使うことで実現できる。
片方のキューは中央値以下の値を降順で格納するキューであり、これをLとする。
もう片方のキューは中央値以上の値を昇順で格納するキューであり、これをRとする。
Lの最大値をM_L, Rの最小値をm_Rで表す。
L, Rともに初期状態は空とする。各更新クエリについて、以下の通り処理する。

* |L| = |R| の場合:
  * a <= m_R ならば L にaを挿入する
  * a > m_R ならば Rからm_Rを削除、Lにm_Rを挿入、Rにaを挿入する
* |L| > |R| の場合:
  * a < M_L ならば LからM_Lを削除、RにM_Lを挿入、Lにaを挿入する
  * a >= M_L ならば Rにaを挿入する

このようにL, Rを管理することでM_Lが常に中央値となる。

次に、|x-a| の和を高速に求める方法を考える。
Sを初期値を0とする変数とし、各更新クエリについて、以下の通り処理する。

* |L| = |R| の場合:
  * a < M_L ならば S を S + M_L - a に更新する
  * a > m_R ならば S を S + a - m_R に更新する
* |L| > |R| の場合:
  * a < M_L ならば S を S + M_L - a に更新する
  * a >= M_L ならば S を S + a - M_L に更新する

このようにSを管理することでSが常に|x-a|の和となる。
