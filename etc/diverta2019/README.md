# diverta 2019 Programming Contest

## A
カテゴリ: 数学

解は N - K + 1 である。

## B
カテゴリ: 全探索

とりえるすべての(r, g)の組に関して、N - (rR + gG) を割り切る非負の整数bが存在するかを数え上げればよい。

## C
カテゴリ: 考察

* 最初に、先頭文字がBではない、かつ、末尾文字がAの文字列を先頭におく（そのような文字列が存在すれば）
* 次に、先頭文字がB、かつ、末尾文字がAの文字列を可能な限り連結する
* 次に、（先頭文字がB、かつ、末尾文字がAでない文字列）と（先頭文字がBではない、かつ、末尾文字がAの文字列）を交互に連結する
* 最後に、余っている文字列を適当に連結する

## D
カテゴリ: 数学

N = km + k = k(m + 1) で表される。
さらに、 m <= sqrt(N) ならば 商は sqrt(N) 以上、かつ、 余りは sqrt(N) 未満になるので、m > sqrt(N) である。
よって、m がお気に入りの数ならば m + 1 は、sqrt(N) + 1より大きい、かつ、 Nの約数である。
これより、 sqrt(N) + 1 より大きい N の約数 d1, d2, ..., dM を列挙し、 di - 1 がお気に入りの数であるものについて、
di - 1 の和を求めればよい。

## E
カテゴリ: 動的計画法

任意のAに関して、0個の仕切りを入れる場合、分割された数列たちの美しさは等しい。
以降、1個以上の仕切りを入れる場合について考察する。

x_i = A_1 xor ... xor A_i とする。
分割された数列たちの美しさがすべて等しいような、数列の分割を組 (i[1], ..., i[k]) で表す。
ここで、組の各要素 i[j] は A の i 番目の要素と i + 1 番目の要素 の間に仕切りがあることを表す。
A_1 xor ... xor A_{i[1]} = A_{i[1] + 1} xor ... xor A_{i[2]} = ... = A_{i[k] + 1} xor ... xor A_N = x_{i[1]} を満たす。
さらに、 x を用いることで、 A_{i[j] + 1} xor ... xor A_{i[j + 1]} = x_{i[j + 1]} xor x_{i[j]}, A_{i[k] + 1} xor ... xor A_N = x_N xor x_{i[k]} と表せる。
したがって、

* 偶数 j に関して、 x_{i[j]} = 0
* 奇数 j に関して、 x_{i[j]} = x_{i[1]}
* k が偶数ならば x_N = x_{i[1]}
* k が奇数ならば x_N = 0

が成り立つ。
したがって、上記条件を満たす仕切り方を数え上げればよい。

動的計画法により、Nに関する線形時間で数え上げられる。
動的計画法のやり方はコードを参照。
