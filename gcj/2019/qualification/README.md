# GCJ2018 Qualification Round2019

## A
カテゴリ: 実装

0以上9以下の整数 d について、 f(d) を以下で定義する。

* d = 0 ならば f(d) = 0
* d = 5 ならば f(d) = 3
* 上記以外ならば f(d) = d - 1

N の各桁 d_i に対して、 f を適用した整数を M とする。
解は次の通りである。

* M = 0 ならば (A, B) = (1, N - 1)
* M > 0 ならば (A, B) = (M, N - M)

## B
カテゴリ: 構築

解は、 P の各文字に対して、 'E' を 'S' に, 'S' を 'E' に変換した文字列である。

## C
カテゴリ: 数学

plaintextの各値を P_0, P_1, ..., P_L とする。
ciphertextの各値を C_1, C_2, ..., C_L とする。
C_i != C_{i + 1} なる最小の i を k とする。
P_k = gcd(C_k, C_{k + 1}) である（P_i は素数であることに注意せよ）。
i < k について、 P_i = C_{i + 1} / P_{i + 1} を用いることで、
P_0, P_1, ..., P_{k - 1} を求められる。
i > k について、 P_i = C_i / P_{i - 1} を用いることで、
P_{k + 1}, P_{k + 2}, ..., P_L を求められる。
解は、P_0, P_1, ..., P_L をもとに復号した plaintext である。


## D
カテゴリ: 構築

整数 k について、 `2**k` 個の '0' と `2**k` 個の '1' が交互に並ぶビット列を送信したとき、返信されるビット列を Y_k とする。
Y_0, Y_1, Y_2, Y_3, Y_4 を用いて解を得る方針である。

高々、15個の worker しか故障していないので、Y_4 は正規表現 `(0{1, 16}1{1, 16})+` にしたがう。
したがって、先頭から16台ずつグループ分けするとき、各グループで故障している worker の個数が分かる。
次に、 Y_3 を用いることで、各グループの左半分と右半分で故障している worker の個数が分かる。
同様に、 Y_2, Y_1, Y_0 を用いることで、この worker が故障しているか特定できる。

